
## RLE (Run Length Encoding)


`aaaaabbbcddd` -> `#5a#3bc#3d`


`a a a a a a b c a b b b b d d a c c c d` - 20 байтов

```
T         L
1 | 1 1 1 1 1 1 1


T - 2 значения: 0 (одиночные символы) или 1 (повторы)

L - 0..127
T=0: L - 1..128
T=1: L - 2..129


[1|4] a [0|2] b c a [1|2] b [1|0] d [0|0] a [1|1] c [0|0] d - 16 байтов


aaaaaabcabbbbddacccd

```



## LZ77

А. Лемпель, Дж. Зив, 1977г.

- заменять повторяющиеся посл-ти ссылками на позиции, где они уже встречались
- скользящее окно (4, 8, 16, 32, ... Kb)

(
offset: uint,
length: uint,
next: char
)

```
win_length = 5

abacabacabadaca


|abacabacabadaca    (0, 0, a)
 ^
a|bacabacabadaca    (0, 0, b)
  ^
ab|acabacabadaca    (2, 1, c)
   ^
abac|abacabadaca    (4, 7, d)
     ^
abacaba|cabad|aca   (2, 1, c)
              ^
abacabaca|badac|a   (2, 1, EOF)
                ^





(0, 0, a)(0, 0, b)(2, 1, c)(4, 7, d)(2, 1, c)(2, 1, EOF)

abacabacabadaca

```


## Код Хаффмана

### Статический Хаффман

$$ A = \{ a_1, a_2, ..., a_n \} $$
А - алфавит

$$ W = \{w_1, w_2, ..., w_n \} $$

$w_i$ - целый вес для $a_i$, 

Тогда набор бинарных кодов $C=\{c_1, c_2, ...,  c_n\}$, где $c_i$ - код для $a_i$:
- $c_i$ не явл префиксом любого $c_j, i \neq j$
- $\sum_{i=1}^n w_i |c_i|$ - минимальна, $|c_i|$ - длина кода $c_i$
называется кодом Хаффмана.

Алгоритм:
1. Составить список кодируемых символов. Каждый символ - узел дерева с весом.
2. Выбрать 2 узла с min весом
3. Сформировать из них дерево с новым узлом с весом, равным сумме весов
4. Добавить дерево в список
5. Повторять пп. 2-5, пока в списке больше 1 узла

`abracadabra` - 11 символов = 88 бит

`a` 5
`b` 2
`r` 2
`c` 1
`d` 1

![[Сжатие без потерь 2024-05-07 17.54.19.excalidraw]]

`a` `0`
`b` `10`
`r` `111`
`c` `1101`
`d` `1100`

`01011101|10101100|0101110`

`abracadabra`
`5 + 2*2 + 2*3 + 8 = 23 бит`


### Динамический Хаффман - алгоритм Виттера

![[Сжатие без потерь 2024-05-07 18.55.10.excalidraw]]

**NYT** - not yet transmitted

Код NYT - код, стоящийся по пути от корня в NYT

**Блок** - узлы с одинаковым весом во всём дереве
Узлов в дереве - 511 - это же - max # узла

Узел:
- символ
- вес
- номер
- левый потомок
- правый потомок
- родитель


`abraca`
![[Сжатие без потерь 2024-05-07 19.56.16.excalidraw]]


```
Список NYT - ASCII (для простоты)
a 97  01100001 
b 98  01100010
c 99  01100011
r 114 01110010
```

1) `cN'' 01100001`
2) `cN'0' 01100010`
3) `cN'00' 01110010`
4) `0`
5) `cN'100' 01100011`
6) `0`

`                                           v`
`01100001|00110001|00001110|01001000|11000110`

`01100001` - a
`01100010` - b
`01110010` - r
a
`01100011` - c
a



### BWT - Burrows-Wheeler transform

Michael Burrows, David Wheeler 1994

`БАРАБАН#`

Прямое:
- все циклические сдвиги
- сортировка по алфавиту
- последний столбец
```
БАРАБАН#
АРАБАН#Б
РАБАН#БА
АБАН#БАР
БАН#БАРА
АН#БАРАБ
Н#БАРАБА
#БАРАБАН




АБАН#БАР
АН#БАРАБ
АРАБАН#Б
БАН#БАРА
БАРАБАН#
Н#БАРАБА
РАБАН#БА
#БАРАБАН


РББА#ААН

```


Обратное:
- сортировка столбца по алфавиту
- приставляем предыдущий столбец в начало
- повторяем до тех пор, пока не получим квадратную матрицу
- строка с символом # в конце - это исходный текст
```
Р
Б
Б
А
#
А
А
Н


РА
БА
БА
АБ
#Б
АН
АР
Н#

```


# MTF - Move To Front

Рябко Борис Яковлевич 1980

```
01234
АБНР#

    01234
Р 3 РАБН#
Б 2 БРАН#
Б 0 БРАН#
А 2 АБРН#
# 4 #АБРН
А 1 А#БРН
А 0 А#БРН
Н 4 НА#БР


3 2 0 2 4 1 0 4

01234
АБНР#

    01234
3 Р РАБН#
2 Б БРАН#
0 Б БРАН#
2 А АБРН#
4 # #АБРН
1 А А#БРН
0 А А#БРН
4 Н

```