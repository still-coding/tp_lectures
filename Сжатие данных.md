
***Сжатие без потерь*** - это процесс комрессии данных, уменьшающий их размер, и при этом после декомпресии данные не изменяются относительно исходных


## RLE - Run Length Encoding

Кодирование длин серий

```
aaaaaaabbbbccd -> 7a4b2cd

abababababab -> 6(ab)

aaaaaaa2bbbbccd -> 7a24b2cd
       ^
```

Как отличить?
1. Обозначить слжебные посл-ти символом, кот нет в исх данных
```
aaaaaaabbbbccd -> [7]a[4]b[2]cd
```
2. Указать кол-во для сжатых и несжатых посл-тей
```
aaaaaaabbbbccd -> 7a4b2c1d
```

Пример
```
aaaaaabcabbbbddacccc                     20 байтов
```


![[Сжатие данных 2024-11-06 12.41.00.excalidraw]]

```
aaaaaabcabbbbddacccc -> 6a bca 4b 2d a 4c

[1|4]a [0|2]bca [1|2]b [1|0]d [0|0]a [1|2]c            14 байтов


aaaaaabcabbbbddacccc
```


## LZ77

А. Лемпель, Дж. Зив - 1977г

- используем скользящее окно, в котором ищем повторы (4 - 32... Кб)
- заменяем повторяющиеся посл-ти ссылками на позиции, где они уже встречались

```
Триплет:
(
	offset: uint,
	length: uint,
	next: char
)
```

Пример
```
win_len = 5

|abacabacabadaca     (0, 0, a)   
 ^
a|bacabacabadaca     (0, 0, b)   
  ^
ab|acabacabadaca     (2, 1, c)   
   ^
abac|abacabadaca     (4, 7, d)   
     ^
abacaba|cabad|aca    (2, 1, c)   
              ^
abacabaca|badac|a    (2, 1, EOF)   
                ^
```


```
(0, 0, a) (0, 0, b) (2, 1, c) (4, 7, d) (2, 1, c) (2, 1, EOF)

(0, 0, b) (2, 1, c) (4, 7, d) (2, 1, c) (2, 1, EOF)
a

(2, 1, c) (4, 7, d) (2, 1, c) (2, 1, EOF)
ab

(4, 7, d) (2, 1, c) (2, 1, EOF)
abac

(2, 1, c) (2, 1, EOF)
abacabacabad

(2, 1, EOF)
abacabacabadac



abacabacabadaca
```


## Код Хаффмана

### Статический

Алфавит $A=\{a_1, a_2, ..., a_n\}$ и веса $W=\{w_1, w_2, ..., w_n\}$.
$w_i$ - целый вес для $a_i$

Тогда набор бинарных кодов $C=\{c_1, c_2, ..., c_n\}$, где $c_i$ - код для $a_i$:
- $c_i$ не является префиксом $\forall c_j, i \neq j$
- $\sum_{i=1}^n w_i|c_i|$ - минимальна, $|c_i|$ - длина $c_i$
называется кодом Хаффмана.

#### Алгоритм

1. Составить список всех кодируемых символов. Каждый символ - узел с весом
2. Выбрать 2 узла с min весом
3. Сформировать из них дерево с новым узлом с весом, равным сумме весов
4. Добавить дерево в список
5. Повторять пп. 2-4 пока в списке больше 1 узла
6. Пометить рёбра 0 слева и 1 справа
7. Получить коды как пути от корня к листам

#### Пример

`abracadabra`: 11 символов = 88 бит

`a` 5
`b` 2
`r` 2
`c` 1
`d` 1![[Сжатие данных 2024-11-20 12.49.35.excalidraw]]

`a` `0`
`b` `10`
`r` `111`
`c` `1101`
`d` `1100`


```
abracadabra


01011101|10101100|0101110

23 бита
```


### Динамический - Алгоритм Виттера

Джеффри Виттер 1989г

![[Сжатие данных 2024-11-27 12.34.31.excalidraw]]


**NYT** (not yet transmitted) - служебный узел в дереве

**Код NYT** - код, строящийся по пути от корня в NYT

**Блок** - набор узлов с одинаковым весом во всём дереве

**Список NYT** - коды символов известные заранее. Например - таблица ASCII.

**Узел**:
- символ
- вес
- номер
- левый потомок
- правый потомок
- родитель

$N = 2L - 1 = 511$ - max # узла


#### Пример

`abraca`

![[Сжатие данных 2024-11-27 13.12.05.excalidraw]]

Список NYT
```
a 97  01100001
b 98  01100010
c 99  01100011
r 114 01110010
	  01100011
```

1) `cN[] 01100001`
2) `cN[0] 01100010`
3) `cN[00] 01110010`
4) `0
5) `cN[100] 01100011`
6) `0`


Сжатое сообщение
```
01100001 00110001 00001110 01001000 11000110
```

Декодируем
```
01100001|00110001 00001110 01001000 11000110
a


01100001 00110001 0|0001110 01001000 11000110
ab

01100001 00110001 00001110 010|01000 11000110
abr

01100001 00110001 00001110 0100|1000 11000110
abra


01100001 00110001 00001110 01001000 11000110|
abraca
```


# Алгоритмы подготовки данных

# BWT

Burrows-Wheeler Transform

Michael Burrows, David Wheeler 1994

### Прямое

- добавить в конец строки символ конца
- получаем все циклические сдвиги влево исх строки
- сортируем по алфавиту
- последний столбец

```
1) БАРАБАН#

2)
БАРАБАН#
АРАБАН#Б
РАБАН#БА
АБАН#БАР
БАН#БАРА
АН#БАРАБ
Н#БАРАБА
#БАРАБАН

3)
АБАН#БАР
АН#БАРАБ
АРАБАН#Б
БАН#БАРА
БАРАБАН#
Н#БАРАБА
РАБАН#БА
#БАРАБАН

4)
РББА#ААН
```

`БАРАБАН` -> `РББА#ААН`

### Обратное

- сортируем столбец по алфавиту
- приставляем исх столбец в начало
- повторяем, пока не получим квадратную матрицу
- строка с символом конца в конце - исх текст

```
РББА#ААН


Р
Б
Б
А
#
А
А
Н

РА
БА
БА
АБ
#Б
АН
АР
Н#


АБ
АН
АР
БА
БА
Н#
РА
#Б
```


## MTF

Move To Front

Борис Яковлевич Рябко 1980

```

РББА#ААН

1) Формируем алфавит

01234
АБНР#


    01234
Р 3 РАБН#
Б 2 БРАН#
Б 0 БРАН#
А 2 АБРН#
# 4 #АБРН
А 1 А#БРН
А 0 А#БРН
Н 4 НА#БР


РББА#ААН -> 32024104

01234
АБНР#

    01234
3 Р РАБН#
2 Б БРАН#
0 Б БРАН#
2 А АБРН#
4 # #АБРН
1 А А#БРН
0 А А#БРН
4 Н

```