A = {a1, a2, ..., aN}

Text = [t1, t2, ..., tM], ti - элемент А
Pattern = [p1, p2, ..., pK], pi - элемент А, K << M

Определить, входит ли паттерн в текст и позицию этого вхождения (или все вхождения)

`dhvbwfdfcqndavxyfczxdqiwonvw`
`        fcz`

M - K + 1 сравнений символов в случае, если полностью отсутсвуют вхождения и подвхождения (в тексте присутсвует часть паттерна, начинающая сначала)




## Конечный автомат

Text = [t1, t2, ..., tM]

Задача: найти `abcd`

Состояния:
0 - нач. состояние
1 - после `a`
2 - после `ab`
3 - после `abc`
4 - после `abcd` - конечное

Переходы:
0 -> 1: `a`
0 -> 0: кроме `a`
1 -> 2: `b`
1 -> 1: `a`
1 -> 0: кроме `ab`
2 -> 3: `c`
2 -> 1: `a`
2 -> 0: кроме `ac`
3 -> 4: `d`
3 -> 1: `a`
3 -> 0: кроме `ad`


![[Поиск подстроки в строке 2024-04-30 07.31.42.excalidraw]]


## Алгоритм Кнута-Моррисса-Пратта

### Префикс-функция

Для произвольного слова X рассмотрим все его начала, одновременно являющиеся его концами и выберем самое длинное, кроме самого X. Обозначим l(X) - префикс-ф-я

$$ l(abc)= \emptyset $$
$$ l(aba)= a $$
$$ l(ababa)= aba $$
$$ l(l(ababa))= a$$

Алгоритм КМП получает на вход слово X, просматривает его слева направо, заполняя массив L, L[i] = |l(x[0], x[1], ..., x[i] )|


X = A#B
A - искомая подстрока
B - строка, в кот. осущ. поиск
/# - символ, который не встречается ни в А, ни в B

A = `aabaa`
B = `aabaabaaaabaabaaa`

`X: aabaa#aabaabaaaabaabaaa`
`L: 01012012345345223453452`


## Алгоритм Рабина

A = {a1, a2, ..., aN}

Text = [t1, t2, ..., tM], ti - элемент А
Pattern = [p1, p2, ..., pK], pi - элемент А, **K << M**

`qwertyuiop`
`tyu`

Двигаем окно длины K по тексту и сравниванем хэш окна с хэшем паттерна.


## Алгоритм Бойера-Мура-Хорспула

1. Составляем таблицу смещений
- Значение смещение = удалённости символа от конца подстроки
- Если символ встречается >1 раза - используем значение, соотв. символу, наиболее близкому к концу
- Символ в конце = длине подстроки, (см. предыдущ, если >1 раза)
- Символы, отсутствующие в подстроке - длина подстроки
2. Сравнение
- Подставляем с начала строки, сравниваем с конца подстроки
- При несоответствии смещаемся на значение, соотв. символу из ***строки***


```
string*
5432166


this is some string
string
  string
        string
             string
```


## Двоичный (bitap, shift-or)

Строка: `abracadabra` длиной n -- haystack
Подстрока: `abr` длиной m -- needle

R - массив бит размером m + 1

```
   0 1 2 3
R: 1 0 0 0


	  a b r a c a d a b r a
0   1 1 1 1 1 1 1 1 1 1 1 1
1 a 0 1 0 0 1 0 1 0 1 0 0 1
2 b 0 0 1 0 0 0 0 0 0 1 0 0
3 r 0 0 0 1 0 0 0 0 0 0 1 0
		  ^             ^
		  
for (i = 0; *(haystack + i); i++)
	for (j = 1; j < m; j++)
		R[j] = R[j - 1] & (haystack[i] == needle[j - 1])


```